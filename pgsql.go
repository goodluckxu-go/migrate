package migrate

import (
	"fmt"
	"math"
	"strconv"
	"strings"
)

type parsePgSQL struct {
}

func (p parsePgSQL) ParseSQL(table tableAst) (sqlList []string) {
	switch table.Active {
	case "Create":
		sql := "CREATE TABLE"
		cSql, sqls := p.mergeCreate(table)
		sql += cSql
		sqlList = append(sqlList, sql)
		sqlList = append(sqlList, sqls...)
	case "CreateIfNotExists":
		sql := "CREATE TABLE IF NOT EXISTS"
		sqlList = append(sqlList, sql)
	case "Update":
		_, sqls := p.mergeCreate(table)
		sqlList = append(sqlList, sqls...)
	case "Drop":
		sql := "DROP TABLE"
		sql = fmt.Sprintf("%v \"%v\"", sql, table.Name)
		sqlList = append(sqlList, sql)
	case "DropIfExists":
		sql := "DROP TABLE"
		sql = fmt.Sprintf("%v IF EXISTS \"%v\"", sql, table.Name)
		sqlList = append(sqlList, sql)
	}
	return
}

func (p parsePgSQL) mergeCreate(table tableAst) (sql string, sqlList []string) {
	sql = fmt.Sprintf("%s \"%s\" (\n", sql, table.Name)
	schemaColumn := columnAst{
		InternetFunc: map[string][]argAst{},
	}
	for index, column := range table.ColumnList {
		columnSql, sqls := p.mergeColumn(column, table.Name)
		if len(sqls) > 0 {
			sqlList = append(sqlList, sqls...)
		}
		if column.LianFuncSort[0] == "Schema" {
			lianLen := len(column.LianFuncSort)
			schemaColumn.LianFuncSort = column.LianFuncSort
			for i := 1; i < lianLen; i++ {
				schemaColumn.InternetFunc[column.LianFuncSort[i]] = column.InternetFunc[column.LianFuncSort[i]]
			}
		}
		if columnSql == "" {
			continue
		}
		if index != 0 {
			sql += ",\n"
		}
		sql += columnSql
	}
	sql += "\n)\n"
	sql += p.handleColumnData(schemaColumn.InternetFunc["Inherits"], "\"", "", "", "", "INHERITS (?)\n", "")
	sql += p.handleColumnData(schemaColumn.InternetFunc["Fillfactor"], "", "", "", "", "WITH (fillfactor=?)\n", "")
	if sql[len(sql)-1] == '\n' {
		sql = sql[:len(sql)-1]
	}
	if schemaColumn.InternetFunc["Comment"] != nil {
		sqlList = append(sqlList, p.handleColumnData(schemaColumn.InternetFunc["Comment"], "'", "", "", "",
			fmt.Sprintf("COMMENT ON TABLE \"%v\" IS ?",
				table.Name), ""))
	}
	return
}

func (p parsePgSQL) mergeColumn(column columnAst, tableName string) (sql string, sqlList []string) {
	firstDao := column.LianFuncSort[0]
	switch firstDao {
	case "Column":
		sql += p.handleColumnData(column.InternetFunc["Column"], "\"", "", "", ",", " ?", "")
		columnType := column.LianFuncSort[1]
		sql += p.handleColumnData(column.InternetFunc[columnType], "", "", "(?)", ",",
			fmt.Sprintf(" %v?", strings.ToLower(columnType)), "")
		if column.InternetFunc["Dimension"] != nil {
			dimension, _ := strconv.Atoi(fmt.Sprintf("%v", column.InternetFunc["Dimension"][0].Val))
			for i := 0; i < dimension; i++ {
				sql += "[]"
			}
		}
		if column.InternetFunc["Collate"] != nil {
			collateList := []string{"pg_catalog"}
			if column.InternetFunc["CollateMode"] != nil {
				collateList[0] = p.handleColumnData(column.InternetFunc["CollateMode"], "\"", "", "", "", "?", "")
			}
			collateList = append(collateList, p.handleColumnData(column.InternetFunc["Collate"], "\"", "", "", "", "?", ""))
			sql += " COLLATE " + strings.Join(collateList, ".")
		}
		sql += p.handleColumnData(column.InternetFunc["Nullable"], "", "", "", "", " NULL", " NOT NULL")
		sql += p.handleColumnData(column.InternetFunc["Default"], "'", "", "", "", " DEFAULT ?", "")
		if column.InternetFunc["GeneratedByDefaultAsIdentity"] != nil {
			args := column.InternetFunc["GeneratedByDefaultAsIdentity"]
			var maxNum string
			switch columnType {
			case "Int2":
				maxNum = fmt.Sprintf("%v", math.MaxInt16)
			case "Int4":
				maxNum = fmt.Sprintf("%v", math.MaxInt32)
			case "Int8":
				maxNum = fmt.Sprintf("%v", math.MaxInt64)
			}
			if len(args) > 3 {
				maxNum = fmt.Sprintf("%v", args[3].Val)
			}
			sql += fmt.Sprintf(" GENERATED BY DEFAULT AS IDENTITY (\n")
			sql += fmt.Sprintf("INCREMENT %v\n", args[0].Val)
			sql += fmt.Sprintf("MINVALUE %v\n", args[2].Val)
			sql += fmt.Sprintf("MAXVALUE %v\n", maxNum)
			sql += fmt.Sprintf("START %v\n", args[1].Val)
			sql += ")"
		}
		if column.InternetFunc["GeneratedAlwaysAsIdentity"] != nil {
			args := column.InternetFunc["GeneratedAlwaysAsIdentity"]
			var maxNum string
			switch columnType {
			case "Int2":
				maxNum = fmt.Sprintf("%v", math.MaxInt16)
			case "Int4":
				maxNum = fmt.Sprintf("%v", math.MaxInt32)
			case "Int8":
				maxNum = fmt.Sprintf("%v", math.MaxInt64)
			}
			if len(args) > 3 {
				maxNum = fmt.Sprintf("%v", args[3].Val)
			}
			sql += fmt.Sprintf(" GENERATED ALWAYS AS IDENTITY (\n")
			sql += fmt.Sprintf("INCREMENT %v\n", args[0].Val)
			sql += fmt.Sprintf("MINVALUE %v\n", args[2].Val)
			sql += fmt.Sprintf("MAXVALUE %v\n", maxNum)
			sql += fmt.Sprintf("START %v\n", args[1].Val)
			sql += ")"
		}
		if column.InternetFunc["Comment"] != nil {
			sqlList = append(sqlList, p.handleColumnData(column.InternetFunc["Comment"], "'", "", "", "",
				fmt.Sprintf("COMMENT ON COLUMN \"%v\".\"%v\" IS ?",
					tableName, column.InternetFunc["Column"][0].Val), ""))
		}
	case "Indexes":
		sql = p.handleColumnData(column.InternetFunc["UNIQUE"], "", "", "", ",", "CREATE UNIQUE INDEX", "CREATE INDEX")
		var fList []string
		for _, v := range column.InternetFunc["Indexes"] {
			colList, _ := v.Val.([]columnAst)
			for _, col := range colList {
				fList = append(fList, fmt.Sprintf("%v", col.InternetFunc["Field"][0].Val))
			}
		}
		indexesName := p.handleColumnData(column.InternetFunc["Name"], "", "", "", "", "?",
			fmt.Sprintf("%v_%v_idx", tableName, strings.Join(fList, "_")))
		sql += fmt.Sprintf(" \"%v\" ON \"%v\"", indexesName, tableName)
		if column.InternetFunc["BTREE"] != nil {
			sql += fmt.Sprintf(" USING btree")
		}
		if column.InternetFunc["HASH"] != nil {
			sql += fmt.Sprintf(" USING hash")
		}
		if column.InternetFunc["GiST"] != nil {
			sql += fmt.Sprintf(" USING gist")
		}
		if column.InternetFunc["GIN"] != nil {
			sql += fmt.Sprintf(" USING gin")
		}
		if column.InternetFunc["SPGiST"] != nil {
			sql += fmt.Sprintf(" USING spgist")
		}
		if column.InternetFunc["BRIN"] != nil {
			sql += fmt.Sprintf(" USING brin")
		}
		sql += " (\n"
		for _, v := range column.InternetFunc["Indexes"] {
			colList, _ := v.Val.([]columnAst)
			for index, col := range colList {
				tmpSql := ""
				tmpSql += p.handleColumnData(col.InternetFunc["Field"], "\"", "", "", "", " ?", "")
				if col.InternetFunc["Collate"] != nil {
					collateList := []string{"pg_catalog"}
					if col.InternetFunc["CollateMode"] != nil {
						collateList[0] = p.handleColumnData(col.InternetFunc["CollateMode"], "\"", "", "", "", "?", "")
					}
					collateList = append(collateList, p.handleColumnData(col.InternetFunc["Collate"], "\"", "", "", "", "?", ""))
					tmpSql += " COLLATE " + strings.Join(collateList, ".")
				}
				if col.InternetFunc["OperationSymbol"] != nil {
					collateList := []string{"pg_catalog"}
					if col.InternetFunc["OperationSymbolMode"] != nil {
						collateList[0] = p.handleColumnData(col.InternetFunc["OperationSymbolMode"], "\"", "", "", "", "?", "")
					}
					collateList = append(collateList, p.handleColumnData(col.InternetFunc["OperationSymbol"], "\"", "", "", "", "?", ""))
					tmpSql += " " + strings.Join(collateList, ".")
				}
				tmpSql += p.handleColumnData(col.InternetFunc["ASC"], "", "", "", "", " ASC", "")
				tmpSql += p.handleColumnData(col.InternetFunc["DESC"], "", "", "", "", " DESC", "")
				tmpSql += p.handleColumnData(col.InternetFunc["NULLSLAST"], "", "", "", "", " NULLS LAST", "")
				tmpSql += p.handleColumnData(col.InternetFunc["NULLSFIRST"], "", "", "", "", " NULLS FIRST", "")
				if index != 0 {
					sql += ",\n"
				}
				sql += tmpSql
			}
			sql += "\n)"
		}
		sqlList = append(sqlList, sql)
		sql = ""
		if column.InternetFunc["Comment"] != nil {
			sqlList = append(sqlList, p.handleColumnData(column.InternetFunc["Comment"], "'", "", "", "",
				fmt.Sprintf("COMMENT ON INDEX \"%v\" IS ?",
					indexesName), ""))
		}
	case "PrimaryKey":
		sql += p.handleColumnData(column.InternetFunc["PrimaryKey"], "\"", "", "", ",", fmt.Sprintf(" CONSTRAINT \"%v_pkey\" PRIMARY KEY (?)", tableName), "")
	case "ForeignKey":
		foreignKeyName := p.handleColumnData(column.InternetFunc["Name"], "", "", "", "", "?",
			p.handleColumnData(column.InternetFunc["ForeignKey"], "", "", "", "_", fmt.Sprintf("%v_?_fkey", tableName), ""))
		if foreignKeyName != "" {
			sql += " CONSTRAINT \"" + foreignKeyName + "\""
		}
		sql += p.handleColumnData(column.InternetFunc["ForeignKey"], "\"", "", "", ",", " FOREIGN KEY (?)", "")
		sql += p.handleColumnData(column.InternetFunc["QuoteTable"], "\"", "", "", ",", " REFERENCES ?", "")
		sql += p.handleColumnData(column.InternetFunc["QuoteColumn"], "\"", "", "", ",", " (?)", "")
		sql += p.handleColumnData(column.InternetFunc["DeleteCascade"], "`", "", "", ",", " ON DELETE CASCADE", "")
		sql += p.handleColumnData(column.InternetFunc["UpdateCascade"], "`", "", "", ",", " ON UPDATE CASCADE", "")
		if column.InternetFunc["Comment"] != nil {
			sqlList = append(sqlList, p.handleColumnData(column.InternetFunc["Comment"], "'", "", "", "",
				fmt.Sprintf("COMMENT ON CONSTRAINT \"%v\" ON \"%v\" IS ?",
					foreignKeyName, tableName), ""))
		}
	case "AddColumn":
		sql = "ALTER TABLE"
		sql = fmt.Sprintf("%v \"%v\" ADD COLUMN", sql, tableName)
		sql += p.handleColumnData(column.InternetFunc["AddColumn"], "\"", "", "", ",", " ?", "")
		columnType := column.LianFuncSort[1]
		sql += p.handleColumnData(column.InternetFunc[columnType], "", "", "(?)", ",",
			fmt.Sprintf(" %v?", strings.ToLower(columnType)), "")
		if column.InternetFunc["Dimension"] != nil {
			dimension, _ := strconv.Atoi(fmt.Sprintf("%v", column.InternetFunc["Dimension"][0].Val))
			for i := 0; i < dimension; i++ {
				sql += "[]"
			}
		}
		if column.InternetFunc["Collate"] != nil {
			collateList := []string{"pg_catalog"}
			if column.InternetFunc["CollateMode"] != nil {
				collateList[0] = p.handleColumnData(column.InternetFunc["CollateMode"], "\"", "", "", "", "?", "")
			}
			collateList = append(collateList, p.handleColumnData(column.InternetFunc["Collate"], "\"", "", "", "", "?", ""))
			sql += " COLLATE " + strings.Join(collateList, ".")
		}
		sql += p.handleColumnData(column.InternetFunc["Nullable"], "", "", "", "", " NULL", " NOT NULL")
		sql += p.handleColumnData(column.InternetFunc["Default"], "'", "", "", "", " DEFAULT ?", "")
		if column.InternetFunc["GeneratedByDefaultAsIdentity"] != nil {
			args := column.InternetFunc["GeneratedByDefaultAsIdentity"]
			var maxNum string
			switch columnType {
			case "Int2":
				maxNum = fmt.Sprintf("%v", math.MaxInt16)
			case "Int4":
				maxNum = fmt.Sprintf("%v", math.MaxInt32)
			case "Int8":
				maxNum = fmt.Sprintf("%v", math.MaxInt64)
			}
			if len(args) > 3 {
				maxNum = fmt.Sprintf("%v", args[3].Val)
			}
			sql += fmt.Sprintf(" GENERATED BY DEFAULT AS IDENTITY (\n")
			sql += fmt.Sprintf("INCREMENT %v\n", args[0].Val)
			sql += fmt.Sprintf("MINVALUE %v\n", args[2].Val)
			sql += fmt.Sprintf("MAXVALUE %v\n", maxNum)
			sql += fmt.Sprintf("START %v\n", args[1].Val)
			sql += ")"
		}
		if column.InternetFunc["GeneratedAlwaysAsIdentity"] != nil {
			args := column.InternetFunc["GeneratedAlwaysAsIdentity"]
			var maxNum string
			switch columnType {
			case "Int2":
				maxNum = fmt.Sprintf("%v", math.MaxInt16)
			case "Int4":
				maxNum = fmt.Sprintf("%v", math.MaxInt32)
			case "Int8":
				maxNum = fmt.Sprintf("%v", math.MaxInt64)
			}
			if len(args) > 3 {
				maxNum = fmt.Sprintf("%v", args[3].Val)
			}
			sql += fmt.Sprintf(" GENERATED ALWAYS AS IDENTITY (\n")
			sql += fmt.Sprintf("INCREMENT %v\n", args[0].Val)
			sql += fmt.Sprintf("MINVALUE %v\n", args[2].Val)
			sql += fmt.Sprintf("MAXVALUE %v\n", maxNum)
			sql += fmt.Sprintf("START %v\n", args[1].Val)
			sql += ")"
		}
		sqlList = append(sqlList, sql)
		sql = ""
		if column.InternetFunc["Comment"] != nil {
			sqlList = append(sqlList, p.handleColumnData(column.InternetFunc["Comment"], "'", "", "", "",
				fmt.Sprintf("COMMENT ON COLUMN \"%v\".\"%v\" IS ?",
					tableName, column.InternetFunc["AddColumn"][0].Val), ""))
		}
	case "ModifyColumn": // todo
	case "ChangeColumn": // todo
	}
	return
}

func (p parsePgSQL) handleColumnData(funcArgs []argAst, argSingleAround, argMulAround, argsExistsAround, sep, sql, defaultSql string) string {
	if funcArgs == nil {
		return defaultSql
	}
	var argList []string
	for _, arg := range funcArgs {
		ar := fmt.Sprintf("%v", arg.Val)
		if arg.Type == "nil" {
			ar = "NULL"
		} else if argSingleAround != "" {
			ar = argSingleAround + ar + argSingleAround
		}
		argList = append(argList, ar)
	}
	argStr := strings.Join(argList, sep)
	if len(funcArgs) > 1 && argMulAround != "" {
		argStr = strings.ReplaceAll(argMulAround, "?", argStr)
	}
	if len(funcArgs) > 0 && argsExistsAround != "" {
		argStr = strings.ReplaceAll(argsExistsAround, "?", argStr)
	}
	sql = strings.ReplaceAll(sql, "?", argStr)
	return sql
}
